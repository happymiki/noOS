/*
 *文件名： led.s
 *作  者： CML
 *描  述： 一步步点亮LED教程的第一个裸机程序
 */
 
#define GPJ0CON 0xE0200240
#define GPI0DAT 0xE0200244

.global _start		//把_start链接属性改为外部，这样其他文件能够看见
 _start:
	// 第一步：把0x11111111写入0xE0200240(GPJ0CON)位置，把所有引脚设置为输出，代码不变
	ldr r0, =0x11111111			// 从“=”看出用的是ldr伪指令，需要编译器判断这个数是
	ldr r1, =GPJ0CON			// 合法立即数还是非法立即数。一般都用ldr伪指令
	str r0, [r1]				// 寄存器间接寻址，功能：把r0中的数写入到r1中的数为地址的内存中去
	
	// 第二步：把中间LED (GPJ0_4)的输出设为0，其余两颗设为1，其他位不管 
	//ldr r0, =((1<<3) | (1<<5))		//相当于0b00101000，即0x00000028
	//ldr r0, =((1<<3) | (0<<4) | (1<<5))	//相当于0b00101000，即0x00000028
	
	// 第二步：把中间LED (GPJ0_4)的输出设为1，其余两颗设为1，其他位不管 
	ldr r0, =((0<<3) | (1<<4) | (0<<5))	//相当于0b00101000，即0x00000028
	ldr r1, =GPI0DAT
	str r0, [r1]				// 把0写入GPJ0DAT寄存器中断，引脚即输出低电平，LED点亮

	b .							//“.”代表当前这一句指令的地址，也是一句死循环（高大上）
/*	
flag:							// 这两行写了一个死循环,为了不让CPU跑飞
	b flag
 */
	
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 